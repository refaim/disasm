Пример дизассемблера .COM-файлов для DOS. Написан на Turbo Assembler 4.1. Разрабатывается группой студентов исключительно в учебных целях.

Авторы:
Кравцов Дмитрий, idkravitz@gmail.com
Харитонов Роман, refaim.vl@gmail.com

Тестирование и code review:
Бураго Игорь
Лукащук Максим
Строкач Александр

Полезные ссылки:
DOS Function codes: http://spike.scu.edu.au/~barry/interrupts.html
Assembler IBM PC: http://mini-soft.ru/book/assem/index.php
TASM 3.0 Manual: http://www.citforum.ru/programming/tasm3r/index.shtml
TASM Reference Book: http://www.codenet.ru/progr/asm/tasm/index.php


FAQ для студентов 236 и 238 групп ИМКН ДВГУ:

Q: Какие программы нужны для работы?
A: 1. Turbo Assembler for DOS (версии не ниже 4.1): http://cloud.github.com/downloads/refaim/disasm/TASM_4.1.ZIP
   2. MinGW Make: http://github.com/downloads/refaim/disasm/mingw-make-win32.zip

Q: Что нужно сделать, чтобы начать писать дизассемблер?
A: 0. Скачать последнюю версию исходного кода: http://github.com/refaim/disasm/zipball/master
   1. В файле make.bat указать путь к TASM на вашем компьютере.
        Пример файла make.bat:
        ------------------------------------------------------------------
        @echo off
        SET TASM_PATH=C:/TASM/BIN
        mingw32-make %*
        ------------------------------------------------------------------
        Путь должен быть набран с использованием прямых ('/'), а не обратных ('\') слешэй. Без завершающего слэша и без кавычек.
    2. Переименовать файл example.asm в p_<название_вашей_команды>.asm. Например: p_jmp.asm, p_mov.asm, p_xor.asm. Префикс "p_" нужен для того, чтобы ваш файл был автоматически подключен при сборке проекта утилитой make. Будьте осторожны: TASM для DOS умеет понимать только имена файлов стандарта 8.3 (не более 8 символов на имя, не более 3 символов на расширение).
    3. В полученном файле переименовать процедуру parse в parse_<название_вашей_команды>. Например: parse_jmp, parse_add.
    4. Дописать полученное имя процедуры в файл funcs.inc, отделив его запятой от уже имеющихся там имён.
        Пример файла funcs.inc:
        ------------------------------------------------------------------
        FUNCS equ parse_jxx, parse_nop, parse_add
        ------------------------------------------------------------------

Q: Как скомпилировать дизассемблер?
A: С помощью файла "make.bat". Как им пользоваться:
    "make [CFG=<debug|release>] [all|clean|debug|test]"
    all -- собрать дизассемблер, clean -- удалить все полученные в результате сборки файлы, debug -- собрать дизассемблер и открыть его в Turbo Debugger'е, test -- собрать тестовый пример test.asm.
    Все параметры опциональны. Запуск "make" без параметров аналогичен "make clean all CFG=debug".
    "CFG=debug" отличается от "CFG=release", как легко догадаться, наличием отладочной информации.

Q: Как это всё работает?
A: Основная процедура main из файла main.asm читает байты из входного файла и в цикле вызывает пользовательские процедуры, которые осуществляют разбор. Имена процедур она берет из файла funcs.inc.

Q: А что за файл такой -- "main.asm"? Что с ним делать?
A: Ничего. Он уже работает и трогать его не нужно, а то всё сломается.

Q: А "common.asm"?
A: Его тоже трогать не надо. Но пользоваться определенными в нем процедурами можно.

Q: Куда же тогда писать мой код?
A: В файл "p_<название_вашей_команды>.asm". Внутри него -- куда угодно. Главное, чтобы была экспортируемая (директивой public) процедура, имя которой записано в файле "funcs.inc".

Q: А что мне разбирать? Откуда брать байты? Куда класть результат?
A: После передачи управления вашей процедуре в регистре si находится адрес буфера со входными данными (байтами из файла), а в регистре di адрес выходного буфера, куда нужно писать выходную строку. Выходная строка должна заканчиваться символом перехода на новую строку (LF, ASCII 10) и не должна содержать символа "$" (ASCII 36). Перед возвратом из процедуры вам нужно прибавить к регистрам si и di количество прочитанных и записанных байт соответственно. Если не удалось распознать команду, трогать эти регистры и писать что-либо в выходной буфер не нужно.

Q: Как быть с регистрами?
A: Состояние регистров до вызова вашей процедуры должно совпадать с их состоянием после возврата (исключая регистры si и di, о которых написано выше). Сохранение регистров обеспечивается директивой uses в начале процедуры: "uses ax, bx, dx" (сохранять нужно только используемые регистры). Кто будет портить регистры, зачёта не получит, гарантирую.

Q: А что за директива "locals" в начале файла?
A: Она позволяет создавать в процедурах локальные метки. Префикс, обозначающий локальность -- "@@" (например, "@@exit").

Q: Я всё прочитал, но ничего не понял. Что делать?
A: Посмотреть примеры: "p_nop.asm" и "p_jxx.asm".
